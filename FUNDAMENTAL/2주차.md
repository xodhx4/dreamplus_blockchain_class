블록체인 강의 2주차

 

# 암호화 해시 함수 

무엇이 비트코인을 변조 방지 데이터 베이스로 만들었나 , 현금 수취, 교환 과정 작동 방식

프로토콜: 중앙 집중식 제 3자의 개입 없이 정보에 관한 합의를 이루게 함>> 정보 조작의 위험 가능성

암호화 해시 함수를 통해 정보의 지문과 같은 역할을 수행하도록 한다

\>>>디지털 코드의 식별자를 받아내기(정보 입력과 정보 출력이 상응하는지 식별 가능한 암호: 세가지 다양한 특성의 함수 가짐    (역상 저항, 2차 역상 저항, 충돌 저항)

** 역상: 해시 함수의 입력& 출력

Or 입력 : 메시지 / 출력: 다이제스트

해시 함수 실행할 때마다, 입력은 동일한 출력을 산출함(모든 해시 함수는 결정적)

유사한 입력이라도 출력은 매우 달라진다

1. #### 역상 저항: 입력 혹은 그 입력에 대한 출력이 정해지면 입력을 계산적으로 결정하기 힘들어짐

(출력이 주어진 입력에 리버스 엔지니어링을 방지하기 위해서)

\>>입력과 출력을 연관시킬 수 있는 방법이 없다(세 사람의 지문이 주어질 때 각각 누구의 지문인지는 해당 사람의 얼굴을 보고서는 판단이 안된다)

입력 자체를 볼 때까지, 특정 입력에 대응되는 출력을 알지 못함

2. #### 2차 역상 저항:  입력 X가 있을 때, H(X)와 H(H’)의 값이 동일하기에 X를 계산하기 힘들다.

(타인이 자신의 고유한 입력을 위조하는 것을 방지, 자신이 가진 해시가 이전에 남의 것이었음을 주장하는 것을 방지, 같은 출력을 내는 여러 다른 입력이 존재하여 고유 식별자를 확보하지 못하는 것을 방지)

3. #### 충돌 저항: 같은 해시값을 가지는 두개의 임의적 입력 X, Y를 찾는 것이 어렵다.

현재 해시 함수 : 임의의 크기의 정보를 수용하며, 고정된 길이의 정보, 출력을 생성한다.

\>>출력보다 입력이 더 많다, 동일한 출력을 생성하는 입력은 결국 존재하게 되어 있다. But 같은 출력을 가지는 두 입력값을 찾기란 어렵다

고유 식별자: 더더욱 고유성을 가지고 위조하기 어려워야 함

 

### Avalanche effect : 암호와 해시함수의 기능

좋은 해시 함수는 입력값에 비추어 출력값 예측이 어려워야 한다(입력을 조금만 바꿔도 출력값이 완전히 달라져야 한다.>> 초 무작위성의 개념을 도입해야 한다)

 

### SHA 256: NSA에서 설계한 암호화 해시 함수, 임의의 크기 정보를 수용, 항상 256비트의 출력

비트코인은 해시 작동마다 SHA 256을 두번 작동시킴, (  SHA256(SHA256(x)) )

변조 방지 데이터 베이스로 만들기 위해 필수적이다 

모든 비트코인 블록체인의 정보 정렬 변화: 해시 함수의 특성에 의해 감지된 것)



### 블록 헤더의 3 요소 

이전 블록해시: 이전 블록의 포인터 역할

머클 루트: 거래 요약

NONCE(임시 값): 작업 증명

블록 헤더: 모든 유형의 정보(난이도, 타임 스탬프) 

블록 해시, 블록 ID: 모든 정보의 연속, SHA256 제곱 해시 함수로 작동

 

### 머클루트

머클 루트는 거래 정보를 포함한다, (머클 트리에서 거래가 생성되기 때문)

머클 트리는 비트코인에도 존재,  해시 이진트리

거래 방식: 초기 단계에서 2N 거래 시작, 2N 이하 거래 보유시 2N 값 구할 마지막 거래 복제

최초 단계에서 한단계 위로 모든 거래를 해시해야 하기 때문, 2N 해시 어느 단계에서 쌍으로 해시를 해나간다, 쌍으로 해시해 나가면 결국 트리 상층부에 단 하나의 해시값만을 가진다       

\>>머클 트리 내에서 거래 조작 시, 트리 내에 증거를 상층부까지 볼 수 있다(한 부분에서 조작한 값이 상층부까지 해시 값이 계속 변경된다, 결국 전체 루트에 펴지면 더 이상 유효한 머클 루트가 아니게 된다

모든 객체들의 그룹의 머클루트는 각자 다른 버전이고, 타인의 다른 버전은 거절된다, (네트워크의 모든 노드와 다르기 때문)

머클 루트가 커질수록, 거래가 데이터 베이스에 존재함을 증명하기 위해 더 많은 정보를 저장해야 한다

내가 머클루트에 거래를 가지고 있음을 증명하고 싶을 때: 모든 거래 내용을 필요하지는 않다 

필요한 것: 중개 해시, 거래 자체

나머지는 제거 하더라도 특정 거래가 머클 루트에 있음을 증명 가능함(거래 해시 결합 등을 해당 해시로 진행했기 때문)>>채굴 최적화 시 효율적인 정보 저장 방식



### 블록 헤더

블록 해시: 블록체인을 블록 체인으로 만들어준다

블록 헤더는 모두 다른 구성으로 이뤄져 있고, 블록 ID: 이전 블록 해시와 동일함

이전 블록 해시를 가져오거나 이전 블록 해시를 해시해서 최신 블록 해시를 얻을 수 있음

이전 블록 해시: 해시 과정을 통해서 계속 이후 블록 해시에 가져와 지게 됨                

머클 루트, 블록의 다른 부분에 변경, 오류가 생기면, 최신 블록 뿐 아니라 나중에 생길 블록에도 영향을 준다, 최신 블록 헤더의 해시에 영향을 주기 때문



### NONCE(임의값) 

 비트코인 작업 증명의 일부

비트코인 : 대부분 역상 해시 퍼즐 사용, 특정 논스값, 무작위값을 찾아야 하고 해시의 세 구성요소가 목표값보다 작아야함?>> 역상 해시 퍼즐, 일부 출력과 상응하는 출력 생성하는 역상을 찾아야하기 때문  

특정 퍼즐: 비트코인 작업 중명, 기타 가상 화폐 작업을 증명하기 위해 실행한다.

해시 퍼즐 요구 사항: 계산이 복잡해야 한다, 매개 변수가 필요하다(문제 해결 여부에 기반, 문제 난이도 조절함- 오래된 사양의 컴퓨터로 퍼즐을 풀 수 있게 난이도가 채굴 속도에 맞춰 변경된다 ), 검증이 쉬워야 한다(해시 함수에 목표값 이하의 해시 출력 조건에 부합하는 입력을 발견하기 위해 수많은 입력 전송(목표 내부의 알고리즘, 네트워크에서는 난이도라고 함)

난이도: 블록 찾는데 필요한 예상 계산 수

전세계 채굴 속도 (해시 레이트) 증가하면 난이도가 증가하고, 그 반대도 성립이 가능하다

난이도: 14일/2016년 블록채굴하는데 걸리는 시간 

(비트코링 블록 시간: 블록당 10분, 2016년 블록 :평균적으로 2주 걸림

2주보다 빨리 풀면: 난이도는 증가하는 것이다)                                              

강의 영상 찍을 당시의 난이도:10, 채굴자가 2016년 블록을 1주일에 채굴하면 난이도는 20이 되고, 4주만에 채굴하면 난이도는 5가 된다. 이를 통해 퍼즐의 난이도는 채굴에 걸리는 시간과 반비례하고, 퍼즐 난이도는 매우 정확하게 변화 해야 한다.

 ![1540620799043](C:\Users\Administrator\Desktop\블록체인 강의 2주차\assets\1540620799043.png)

 

  

0 헤더 논스 기반, 논스 최대 용량까지 상승하고 논스에서 특정 값을 얻을 때마다 해시 함수에서 테스트 한다. 

논스의 목표 값 이하인 특정 값 생성 여부를 확인 가능하다. 이에 해당하는 논스를 얻고, 블록으로 나머지 네트워크에 제출한다

논스가 32비트량 초과 시, 변경 방법을 찾아야 한다 왜냐면 오버플로우가 발생하고, 0으로 되돌아가기 때문이다.

 

 

머클 트리에서 올바른 거래는 채굴자들 스스로 보상을 진행하는 코인 기반 거래이다. 이들이 변경되면서 증가가 가능한 논스가 존재하고, 또한 머클 루트를 변경하여 전혀 다른 해시 퍼즐을 취할 수도 있다. 헤더에서 논스를 통해 작동하고, 오버플로우 될때까지 계속 작동한다. 머클루트 상승시키고, 다시 돌아와서, 목표 이하값을 출력하고 발견할 때까지 퍼즐을 생성하는 것이다. 이때 주의할 점은, 해시 가장 앞에 0이 없다면, 이는 유효한 블록이 아닌 것이다

![1540620839177](C:\Users\Administrator\Desktop\블록체인 강의 2주차\assets\1540620839177.png)

블록체인 소프트웨어에서 알고자 하는건 얼마나 많은 사람들이 출력값에 기반해 주소를 바꾸는가 이다. 왜냐하면 체인 주소도 결국 산출물의 일부이기 때문이다. 블록 당 거래 비용은 대략 4달러인데 이는 채굴자에게 엄청난 인센티브가 된다. 

 

타임 스탬프와 난이도가 존재한다(난이도의 숫자 의미를 알 필요는 없다. 너무나 많은 숫자가 있기 때문) 퍼즐 숫자가 더 커지면 난이도는 더욱 어려워진다. 그리고 네트워크에서 블록을 발견하기 위해서, 더욱더 강한 계산 능력을 필요로 하게 된다.

### ECDSA

디지털 서명을 사용해서 익명으로 네트워크에서 활동하기 & 비트코인이 개인키, 공개키, 주소로 익명성을 추구하는 법

ECDSA: 알고리즘을 사용하는 개인키와 공개키를 형성한다

상대방의 공개 키와 서명을 받아도 개인키를 유추하기는 힘들다. 그 원리는, 디지털 증명 서명 시스템을 필요로 한다(증명 가능한 메시지 원본-message origin, 메시지 부인 방지 검증-non repudiation, message integrity)

ECDSA는 타원 곡성 디지털 서명 알고리즘으로 이산로그적 문제를 제기할 수 있는 유한 아벨군을 정의해야 한다(범위가 유한하다는 뜻) 이를 통해 특정 길이의 키를 설정할 수 있다(무한한 크기가 아닌)

유한체 소수주문 비용은, 소수 p를 가지고 모듈러 연산 내 존재하는 유한체 내부에서 유지시킨다. 이는 계산적으로 효율적이다

타원 구성하는 트랩도어 함수는: 연산기능, 개인 키에서 쉽게 확인이 가능하다. 원리는 코트 탄젠트 프로세스로서, 소수점 곱셈 정의를 사용한다. 

![1540620877945](C:\Users\Administrator\Desktop\블록체인 강의 2주차\assets\1540620877945.png)

 

타원 곡선 상에, 선을 긋고 교차하는 점 R을 구한다. R을 X축에 반영하고, 이 x와 타원 곡선과 만나는 점을 구하면 P *Q를 얻을 수 있다. 그리고 P와 P *Q를 교차해서, 선을 긋고 다른 교차점 구하고 이를 X축에 반영하면, 

P*P *Q를 구할 수 있다. 반복하면, M이 거대하고 암호적으로 안전한 수라고 할 때, 이것이 private key가 된다. P^M(P의 M승)은 공개 키가 된다. 개인 키를 통해 공개 키를 얻는 것은 쉽지만, 공개 키로 개인 키를 확인하는 것은 매우 어렵다

이는 M기반의 P^M 로그 함수에서 M을 계산하기 어렵다는 뜻으로,M= logMPM  을 구하는 것은 수학적으로 계산이 불가능하다. 이를 트랩도어 함수라고 부르는데, 일방향 함수이며, 특수 정보 없이는 함수의 역을 구하기 어려운 함수를 의미한다

 

이를 통해 보안을 한층 강화하고, 비트 코인 주소가 사람이 이해할수 있는 형태가 되기를 원한다. 보안을 위해, 공공키는 공공키 해시 변경시, 이중 해시 함수를 사용한다. 첫번째 해시할 때에는 SHA256을 사용하고 두번째 해시에는 RIPEMD160함수를 사용한다. 이 두 함수를 통해 이중 해시를 하면 퀀텀 저향이 가능해지는데, 양자컴퓨터로 억지로 계산해도 절대로 복호화 할 수 없음을 의미한다.

 

방식은 퍼블릭 키를 우선 이중 해시(SHA256과 RIPEMD160함수를 거침)하여 퍼블릭 키 해시를 구하고, BASE58check Encode과정을 통해 비트코인주소를 구한다. 이때 BASE58이란, 일반 알파벳과 같으나 숫자 0과 대문자 알파벳O를 제외하고 마찬가지로 숫자 1과 소문자 I 또한 제외하여 인간이 쉽게 구분할 수 있게 하는 인간 친화적인 부호를 사용한다. 이 BASE58은 몇자리의 수를 스트링 시작 부분에 넣고, SHA256(SHA256(x))를 거쳐 해시를 하고 check sum을 얻은 뒤에 주소 마지막 부분에 그 값을 넣는다. 이 과정은 비트코인 주소를 디코딩 소프트웨어를 쓰기 쉽게 만들어주고, 주소의 스펠링이 올바르고 유효한지 확인할 수 있게 해준다. 실수로 철자를 빼거나 무질서하게 작성하면, 주소 처음부터 해시가 가능하고, checksum으로 유효성 여부를 확인할 수 있다

 

### 비트코인 스크립트

 

모든 비트코인 거래는 UTXO 기반의 모형이다. 이는 모든 거래의 입출력이 매칭이 가능하다는 뜻이다. 그리고 모든 거래는 특정 주소로 보내진 비트코인을 되찾는 것을 의미한다. 이 비트코인은 개인 및 공공키를 사용해서 되찾는 것이다. 그리고 모든 거래는 상자 안에 존재하지만, 모든 거래와 블록이 같은 것을 의미하지는 않는다

 

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.png)

 

해제 스크립트란, 거래를 작성하는 상대방에게 제공 받고 해당 거래의 출력에 있던 비트코인을 되찾기 위해서 서명, 공개키의 정보를 제공한다. 그리고 거래 출력 구간은 비트코인의 해당 주소를 지정하고, 스크립트 성공적으로 이끄는 정보를 제공하고 비트코인을 청산한다

 

비트코인 총합이 주소나 공개 키 소유자의 서명을 해시하는 공개키로 청산할 수 있다. 

비트코인의 입출력은 스크립트라고 이해하면 된다. 

비트코인/UCS를 위해 제작, 스택을 기본으로 한다

잠김 스크립트: 이전 거래의 출력사항을 비트코인 사용을 위해 확인한다. 비트코인의 총량을 결정하고 스크립트 잠금 해제를 진행할 수 있는 모든 이에게 할당한다. 

잠금 해제 스크립트: 해당 거래에서 비트코인 사용 시 제공한다.

비트코인 검증 노드: 네트워크에 존재하고, 해당거래 작동여부를 검증한다.

기본적으로 잠금 해제 스크립트를 취하고, 잠금 스크립트와 함께 작동되는 곳에 입력을한다

 

### 데이터 데이터 스택

스택에 내용을 작성하고, 위에서 아래로 내용을 작성한다. 해당 스크립트를 실행하는 동안, 서명을 얻어야 한다. 일종의 순차로 표현을 하고, 어떤 형태던지, 누군가의 서명이 된다.

스택에 공공키, 서명을 넣으면 상단의 잠금 스크립트로 이동하고 스택의 상단 항목을 복사, 두개의 공공키를 얻게 된다. 상단 해시를 가지고, 스택 상단 항목에서 해시를 한다. 그리고 공공키 해시(출력 스크립트에 존재, 해당 스크립트를 잠금 해제하는 공공키 해시한다.) 

거래를 보내는 사람이 구체화를 하고, 실제로 같은 공개키 해시인 것을 확인, 해당 서명이 공개키 해시 소유한 사람의 실제 서명인지 확인하는 절차를 거친다

무언가가 블록 체인에 기록되면 보안 프로토콜로 인해 절대 변경이 불가능하다. 그러나 언제 기록이 되었는지 시간은 알 수 있다. 

비트코인에 정보를 저장하기 위해서는 본인의 출력 스크립트와 OP-RETURN을 사용한다. (거래 진행하는 동안, 소유한 인력을 확인 가능하고, 출력에서 원하는 것을 작성할 수 있다)

그래서 오류가 발생한 OP-RETURN을 작성할 수 있고, 스크립트가 작동을 중지한다. 그리고 그 아래에는 데이터 작성을 위한 작은 공간이 존재한다. 

문제는 기본적으로 모든 입력에 대한 출력을 나타내지는 않는다는 것이다. 따라서 출력이 존재하지 않으면, 해당 거래에 입력한 모든 비트코인은 손실된다. 하지만 이 방식의 장점은 원하는 것을 작성할 수 있다는 것이다. 무언가를 작성했다는 증명의 수단으로 비트코인을 날려서 이를 증명하는 방식을 택한 것이다

​                                                                                                                                                     

### 거래의 형태

 

1. ##### Pay to Pub Key Hash 거래

누군가에게 거래를 보낸 사람이 공개키의 해시값에 지불하고 있다고 명시를 한다. 청산하는 사람이 해당 비트코인을 청산하기 위해, 공개키 정보를 제공해야 한다

2. ##### Pay to Script Hash

거래를 보내는 사람이 스크립트에 해시를 명시한다. 보다 복잡한 정보, 데이터가 주소, 비트코인 청산을 위해 요구된다. 예를 들어 고객이 복잡한 방식으로 스크립트 작성하지 않게 하기위해, 판매자가 스크립트를 제공하고 해당 스크립트 해시에 고객이 비용을 지불한다. 이를 통해 해당 금액을 해시하고 청산하는 것이다.

​                                                                                                                                           



비트코인 IRL: 일반 사용자가 비트코인 네트워크와 접속하는 방식

(비트코인 거래만 할지, 풀노드로서 네트워크를 지원할 지도 관련)

비트 코인의 개인: 개인 키로 고유하게 식별된다(개인키: ECDSA, 타원 곡선 디지털 서명 알고리듬을 통해 거대한 임의의 숫자로 구성됨, 공개키를 해시하여 주소를 얻음, 주소는 사이즈가 매우 크다, BASE58을 사용해서 주소를 보다 더 쉽게 읽을 수 있다)

비트코인 네트워크에서 발생하는 사건들은 주소에 따라 달라진다, 가지고있는 키를 파악하는 일부 소프트웨어를 사용하면 더 쉽게 진행이가능하다>> 비트코인 지갑이 생김

##### 기본 단계: 비트코인 지갑은 개인키를 기록한다

##### 핫 지갑: 언제나 인터넷에 연결된다

##### 콜드 스토리지 지갑 : 항상 오프라인 상태이다

웹 지갑의 주요 속성: 개인키가 제 3자가 소유한 클라우드 서버 등에 저장된다

따라서 개인은 보유한 개인키를 유지할 능력이 없다, 개인키를 기억하는 것이 매우 중요하다

#### 콜드 스토리지 지갑 종류 

1. 종이 지갑: 종이에 개인키를 적어서 안전한 곳에 두는 것

2. 하드웨어 지갑: 마찬가지로 인터넷이 연결 안됨, 컴퓨터를 USB에 연결하면 USB를 통해서 해당 하드웨어 지갑에 거래가 전송됨 Tans-execute environment라고 불리는 환경에서 거래에 서명함

   그러면 pc는 인터넷에 연결되어 있더라도 하드웨어 지갑 자체는 인터넷과 연결 안됨, 해당 거래서명 생성은 안전한 환경에서 처리된다.

3. 브레인 지갑: 일종의 연상 기호 영문자로 구성됨, 쉽게 기억할 수 있는 것을 선택, SH256과 같은 단방향 해시알고리즘으로 개인키를 얻는다. 

   문제: 무차별 대입 공격(브루트포스)의 속도를 제한할 수 있는 방법이 없다       

   해결: 유명 영화 대사를 선택, 이를 발견해서 부르투 포스를 이용해서 개인키를 획득한다(인간이 무작위로 문자나 일련의 단어를 선택하는 것처럼 랜덤하지는 않기 때문)

   키 스트레칭을 통해서 억지 공격 시도를 완화할 수 있다    

   :원본 브레인 지갑을 취하고 여러 번 해시하는 것, 무작위 출력을 입력으로 가져가고 2^20 정도 상향 반복한다. 그리고 누군가 개인키에 억지 공격을 시도하기 위해서는 연상기호와 해시를 몇번 했는지를 추측해야 한다. 그러면 개인 키를 획득할 때까지 난이도가 올라가게된다



Coin base와 같은 웹 지갑 선택 시, 개인키는 제 3자의 클라우드 서버에 저장된다. 이 경우 coinbase가 다운되면 개인키는 분실하고 돈을 잃어버리게 될 것이다. 혹은 자기가 잃어버리는 것이 두려울 경우 그 책임을 coinbase에 전가하고 싶을 수도 있다. (이용자의 선택에 따라 지갑 종류를 선택해야 한다. 

비트코인 최초 획득 방식:  비트코인ATM 기기를 사용한다

비트코인 스마트폰 앱, 지갑 앱만 잘 관리하면된다

지갑 주소가 담겨있는 QR 코드가 있고, 스캔해서 일부 현금을 ATM 기기에 넣고 송금하면 비트코인을 전달받을 수 있다.

비트 코인 거래소도 존재, 비트코인의 시가를 결정한다(다양한 화폐를 통해서 비트코인 거래를 진행하기 때문)

교환소 종류: 중앙 집중/ 비중앙 집중                                     

중앙집중형: 단일 장애 지점이 존재함, 

비중앙 집중형: P2P 방식으로 거래 진행된다, 제 3의 기업 기관이 이용자들의 자금을 보유하지 않는다, 거래 이루어질 때 비신뢰 거래를 허용함                                  

​                   Ex) Bitsquare, Bitshares, Openledger, NXT, Counterparty 등이 존재함

### 지갑 메카닉

비트코인 네트워크의 풀 노드는 현재 140 기가 바이트에 달하는 거대 블록을 다운받아야 한다

그러나 비트코인 앱 지갑을 다운받는다면 메가바이트로 용량이 줄어든다. 왜냐면 단순지불검증 기술을 보유하고 있기 때문이다.

비트코인 네트워크를 쿼리해서 이전 블록에 해당 거래가 포함되었는지 확인해서 유효성을 검증한다

누군가가 경유 거래를 보낸 경우 해당 거래를 합법성 확인하고 싶을 때 풀노드 비트코인을 쿼리한다. 풀노드는 머클 루트를 알려주고, 머클 트리의 곁가지는 해당 거래가 이전 블록에 포함되었는지 증명하는 머클 증명 구성에 필요하다. 따라서 블록체인 전체를 다운 받는 것을 피할 수 있다. 단순히 네트워크를 이용해서 상대방에게 알릴 수 있음 

SPV 노드는 단순지불 검증이다(lightweight, thin client로도 불림) 

Spv 노드의 정상 작동 확인하기 위해 필요한 가정:

1. 새로운 블록 헤더가 실제로 존재하는지 확인 (장기적으로 체인은 정직해진다)

​         비트코인 지갑의 가장 중요한 특징은 다중 서명을 제공한다는 것, end of end    

​         거래가 가능해짐

2. 가명과 비트코인의 재사용이 없어야 한다(실제로 소유한 비트코인 양을 누군가 확인하지 않도록 하기 위해서) 비트코인 블록체인에서 누구도 소유자의 활동을 추적할 수 없다


새로운 키를 만드는 것은 저렴하고 , 하나의키를 절충하는 것과 다른 키를 절충하는 것은 별개의 것이고 독립적이다.

현재: 계측 결정 지갑, HD 지갑을 사용한다. 기능은 시드키 및 마스터 키로 작동한다. 이를 통해 더 많은 개인키, 개인& 공개키 쌍을 생성 가능하다. 시드키 및 인덱스 숫자를 통해서 작동하는데, 50번째 키를 생성할 때 인덱스 번호는 50이 된다.

거래소는 수많은 통화를 이용해서 거래를 하기 때문에 수많은 주소가 필요하고 HD 지갑을 사용한다. 그래서 모든 주소를 기록 할 때 서버가 감당할 수 없다.

 

거래소에 등록하고 사용자를 등록하면 시드키를 할당한다고 가정할 때, 새로운 주소를 만들 때마다 계산을 실행하여 새로운 주소를 가질 수 있다. 이때 거래소는 주소를 계속 업데이트를 할 필요가 없고 해당 서버가 계산을 쉽게 처리할 수 있다. 

##  

##  

### 풀노드 및 비트코인 네트워크

 

비트코인 채굴자는 수익 및 비용에 기반해서 채굴 진행

  1.우선 전체 블록체인 거래 내역을 다운받는다

2. 거래 관련 정보 확인, 메인 풀이라는 곳에 저장

3. 해당 거래를 이용 새로운 블록을 생성한다

4. 거래 내역을 보유하고, 머클 제너레이터 및 머클 루트에 해시한다

5. 이전 블록 해시를 얻고, 다음 작업 증명인 유효 임의값을 획득한다

6. 임의값(논스)를 획득하면, 네트워크에 블록을 제출한다

7. 블록에 네트워크에 받아들여지고 가장 긴 체인과 연결될 때까지 기다린다. 

8. 모든 절차가 끝나서야 이윤을 얻는다. 

 

채굴자의 수익 및 비용에 대한 분석: 

수익= 블록 보상+ 거래 수수로

비용= 고정비용+변동비용 ‘

채굴 소익이 현금 비용보다 높다면, 이윤을 얻는다 

##  

블록 보상은 채굴자가 네트워크에 블록을 제출 할 때마다 발생, 현재 블록당 12,5의 보상이 존재한다, 이는 비트코인이 처음 도입된 후 계속 지속된 것임

보상은 50에서 시작했고 점점 줄어들었고 현재는 12.5, 결국에는 0이 될 것이다

2140년 쯤이면 더 이상 새로운 비트코인을 채굴할 수 없다 (총 2100만 비트코인이 생산될 것)

마음대로 돈을 찍어낼 수 없다면, 돈은 가치가 없어지게 된다. 그래서 비트코인 총량을 제한함

블록 보상 자체는 주화장치이면서, 사람들을 정직하게 만들어준다:

이익은 행동 프레임의 1차 동기이다

그리고 정직에 대한 인센티브가 증가하면 네트워크는 안전해진다(익명인 사용자를 처벌할 수 없고, 이들 기록을 알 수 있는 중앙 관리소도 존재 안함 그래서 효과적으로 자금을 회수하고 처벌할 수 없다)

따라서, 정직한 채굴자에게 보상을 주자, 그들이 소비한 비용에 인센티브를 주자(전기료, 하드웨어 비용, 운영비용 같은 것에 대해)

아무리 개인의 채굴 능력이 뛰어나도, 네트워크와 같이 가기 위해서는 보상이 필요하다

비트코인을 채굴하더라고, 비트코인 자체에 신뢰성이 없고 코인 가치를 신뢰하지 않는다면 채굴 동기는 전혀 나타나지 않을 것이다

##  

블록 보상에는 추가 거래 수수료가 발생한다: 입력값과 출력값의 차이이다. 

거래 전송자는 추가 비트코인 일부를 입력하고, 타인 거래가 아닌 본인 거래가 승인되기를 원함

일반적으로 수수료 비율을 통해 구매하는 방식으로, 채굴자들은 거래 수수료에서 최대한 이익을 얻을 수 있다. .  

블록 보상이 0이 된다면, 거래 수수료가 채굴의 유일한 동기가 된다

##  

채굴 비용: 하드웨어 구입해서 작동시켜야 하기 때문에 고정 비용 중 하드웨어 비용이 가장 크다.(CPU, GPU, FFGA, ASICs 등) 

CPU 하나로 비트코인 하나 채굴에는 760만년 정도가 걸린다.

GPU는 70만년 정도 걸리고 전력 소모도 크고 발열이 심하다(채굴에 최적화 되어 있지 않기 때문), 5년 전만 해도 ASICs 이전에 채굴에 가장 많이 사용되었고, ASICs로 해시 퍼즐 해결 할 수 없는 제트 캐시 밑 이더리움 채굴에는 아직 사용 중이다 

단점은 채굴에 적용 안되는 구성 요소가 너무 많다(비트 쉬프트는 많지만, 연산 횟수는 나타나지 않음)  대규모 채굴에는 적합하지 않음

FPGA: 비트코인 전용 하드웨어와 일반용 하드웨어 절충한 형태 

ASICs: 비트코인 네트워크에 지배적인 하드웨어

초당 14조의 해시는 BItmate에서 개발한 Antminer S9를 의미, 가격은 3000달러로 비싸지만 한 블록 찾는데 10.9년이 걸린다, 소형 장치로도 성능을 조절 할 수 있다

단점: 제조 비용이 많이 발생한다, 생산이 중앙집중화되어 있다.

중국의 Bitmate는 네트웨어의 70프로를 생산하고 ,해시레이트도 유사하다, 독자 기술로 이미 전세계 장악(비트코인 설계는 탈 중앙화를 의도했지만 이런 독점의형태는 탈중앙화와 상충한다)

전반적 운영 비용, 채굴에 들어가는 에너지와 관련이 있다. 에너지에는 하드웨어 구축, 전원 공급, 유지에 사용된다(합의 프로토콜 및 투표에 참여하기 위해 사용한 것이라고 할 수 있다) 창고와 인력 등 운영 규모에 따라 달라지는 인프라도 존재함 이런 인프라를 관리하는 인력이나 수용 장소가 없다면 제대로 운영이 되지 않음

또한 채굴 시 발생하는 발열 량은 사용하는 전기 량에서 낭비되는 것인데 이를 데이터 용광로라는 접근법을 누군가가 고안함(채굴하는 열을 겨울의 히터로 사용하는것)

##  

### REAL WORDL MINING

중국 실제 비트코인 채굴장: 거대한 선풍기와 조잡한 ASICs를 덕지덕지 연결함(비용을 줄였다) 

작은 능력 보유한 사람들이 모여 같은 블록에서 자원을 소비하는 형태의 채굴장이 존재한다. 보상금 및 임무를 적절히 분배하는 채굴장 관리자가 해당 채굴장을 운영한다. 그리고 채굴장 관리자는 서비스를 제공하고 채굴자들이 해시 파워를 모아야 하는 중심점 역할을 해서 블록 보상을 가져간다

개인 및 작은 규모의 채굴자가 이런 채굴장에 참여 가능하다

일반인 개개인이 블록을 찾는 것은 어렵다. 

비트코인 네트워크에서 모든 노드는 고유한 소프트웨어를 보유하고 있다. 채굴자는 어떠한 정보도 다운받을 필요가 없고, 채굴장 소프트웨어만 다운받으면 된다. 이를 통해 채굴자는 채굴 퍼즐을 받고 쉐어라는 것을 제출한다 문제는 채굴장 관리자는 신뢰할 수 잇는 사람이어야 해서, 다시 한번 중앙 집중화의 문제가 발생한다.(관리가가 악의적으로 해시 파워 방향을 변경, 수많은 공격에 노출 시킬 수 있기 때문에 중앙화의 위험이 생기는 것)

비트코인 채굴자들은 거대한 채굴장을 선호하지 않는다  

##  

개인 채굴: 블록 채굴 시까지는 보상을 받지 못하고, 기다리는 시간이 길면 채굴 장비도 낡게 된다

채굴장 사용: 해당 채굴장이 네트워크 해시 파워의 6분의 1을 보유하고 있어서 6개마다 하나의 블록을 찾을 수 있다면, 한시간마다 58퍼센트 보상을 가진다

비트코인 채굴이 안정적일 수록, 비트코인에 더 강력한 채굴 파워가 관여하게 된다면, 채굴장이 더 인기가 높아진다 

채굴장 참여시, 쉐어를 제출해서 채굴장에서 채굴을 함을 증명한다. 관련 퍼즐에 작업하고 있음을 보여주기 위해서, ‘near valid block’이라고 불리는 쉐어를 제출해야 한다. 그리고 선택 포인트에 따라서 지불금을 준다. 유효 블록 헤더를 생성하는 논스 혹은 유효 블록은 쉐어와 같은 방식으로 지불된다

##  

### 채굴장 방식

1.     PPS(Pay per share)는 채굴자에게 더 좋은 결과를 가져다 준다, 쉐어를 제출할 때마다 지불금을 받기 때문.  채굴장이 블록을 발견 못해도, 채굴자는 채굴장 편차에 대해 걱정할 필요가 없다. 채굴장이 블록을 발견 못해도 지불 금액을 받는 것이 가능. 하지만 채굴장이 특정 공격을 일으킬 수 있는 추가 지불을 진행하지 못하면 채굴자의 유효 블록을 생성하는 임의값을 생성하려는 동기가 사라진다. 

2.     비례법(proportional)은 채굴자에게 해롭고, 채굴장 유지하는데도 어렵기 때문에 사용하지 않는다 채굴장은 블록 발견 시 지불 금액을 제공한다. 편차가 더 높지만 채굴장에게는 좋다(채굴장은 뭔가를 발견할 때까지 지불 금액을 제공하지 않아도 되기 때문이다.) 보상을 발견할 때까지 지불 금액에 대한 어떤 보장을 하지 않아도 된다. 개인 채굴자는 이 방식에 더 큰 리스크를 감수해야 한다

##  

블록 퍼즐 채굴을 변화시키는 파일 코인: 분산형 저장 시스템

지역 서버에 정보를 저장하고 무작위로 구성된 임의의 정보를 묻는 질문을 받게 된다 이같은 경우 어떤 질문을 받을 지 예측할 수 없고 모든 내용을 저장해야 한다 그리고 해당 정보를 보유하고 있음을 계속 증명해야 한다

문제는 유용한 작업 증명이 알고리즘적으로 생성되지 않기 때문에 계속 문제가 발생한다. 개별 채굴자들은 무한한 퍼즐 공간을 보유하고 있지 않다. 

비트 코인의 장점은 항상 풀어야 하는 퍼즐을 보유하고 있다.

##  

### 비트코인 합의

비트코인 코어는 소프트웨어를 작동시키는 개발자를 가리킨다

또한 풀노드 실행에 사용되는 컴퓨터에 다운받는 소프트웨어를 의미하기도 함

해당 소프트웨어슨 거래 및 지갑을 점검, 프로토콜 업데이트는 포크를 통해 이뤄짐

포크에는 하드 포크와 소프트 포크가 있다

하드 포크는 수많은 노드가 일부 소프트웨어를 실행하는 경우 이용됨, 일부 노트가 업그레이드되어 더 이상 정보를 받을 수 없게 된다. 따라서 오래된 노드는 새로운 노드를 거부하게 된다. 2메가바이트로 블록 크기를 늘리고 싶을 때에는 새로운 노드가 해당 블록 크기를 구성하게 됨. 오래된 노드일 경우 1메가 바이트만 수용이 가능하다. 그러므로 새로운 노드와 오래된 노드는 서로 상호작용이 불가능. 그리고 해당 프로토콜이 두 개로 나눠진다. 따라서 이들은 서로 다른 버전으로 작동하게 되는 것이다. 

소프트 포크는 새로운 노드가 오래된 노드보다 더 구체적인 일을 수행하는 것. 모든 새로운 노드는 유효하나 오래된 노드는 새로운 노드와 상호작용할 수 없다. 새로운 노드가 오래된 노드를 거절해도 네트워크에 참여하고 있다고 생각할 것. 그래서 오래된 노드가 새로운 노드로 업그레이드 하도록 동기를 부여한다. 왜냐면 오래된 노드는 새로운 네트워크에 더 이상 참여할 수 없고 합의 프로토콜에 참여할 수 없기 때문이다.

##  

BIP: 업데이트 제안하는 방식 

세 타입: standards Track BIPs, Informational BIPs, Process BIPs

코인베이스 논스에 특정 bit을 변경하는 것으로 시그널을 줄 수 있다.

이곳 수천개의 블록에서 사람들은 특정 ,bip의 신호를 보유한다. 그리고 이를 통해서 네트워크를 지원하는 컴퓨터 수량을 추정할 수 있다.

##  